# 대표적인 프로젝트 한 개 이상, 각각에 대해서 1) 진행 방식, 2) 본인의 역할, 3) 문제 해결 경험을 포함하여 구체적으로 설명해 주세요.

## 배달 시간 예측 모델 실시간 서빙 서비스 구축 프로젝트

### 활용 기술

- 인프라/클라우드: GCP, k8s(GKE), Container, Helm, skaffold, Terraform, Lens
- 백엔드: FastAPI(Python), poetry, pandas
- 프론트엔드: React, TypeScript, CSS(LESS), NextJS, EChart, Material UI
- 데이터베이스: BigQuery, PostgreSQL, Kafka(Confluent Cloud), Redis
- CI/CD: Github Action, ArgoCD, Google Cloud Container/Artifact Registry
- 모니터링/기타 도구: Google Cloud Logging, Datadog, Airflow, Jupyter Notebook, Github, Locust

### 본인의 역할

- Team Lead, Project Tech Lead
- 기술적 의사 결정(오픈소스 검토, 기술 스택 결정, 코딩 표준 및 스타일 가이드 설정, 코드베이스 구조 설계 등)
- 아키텍처 설계, 데이터베이스 설계, 백엔드 개발
- PO, ML 엔지니어와 개발자들 간의 기술적 가교 역할 수행
- ML 모델을 실시간으로 서빙하기 위한 API 설계 및 개발
- 가게 설정 화면 기획 및 프론트엔드 개발 가이드
- 대용량 트래픽 처리를 위한 시스템 아키텍처 설계 및 구현
- 모니터링을 통한 지속적인 성능 개선 및 최적화
- 서비스 안정성 확보를 위한 장애 대응 및 복구 전략 수립

### 진행 방식

- 2주 단위의 스프린트로 애자일/스크럼 방식 채택
- 백엔드 개발자, 프론트엔드 개발자, Data/MLOps 엔지니어로 구성된 팀 운영
- 주 2회 ML 팀과 서비스 개발 팀 간의 기술 공유 세션 진행
- 지속적 통합/배포/학습(CI/CD/CT) 파이프라인을 구축하여 모델 및 서비스 업데이트 자동화

### 문제 해결 경험

- 실시간 처리 지연 문제: 피크 시간대에 초당 수백 건의 예측 요청이 들어오면서 응답 시간이 크게 증가하는 문제가 발생했습니다.  
이를 해결하기 위해 모델 경량화 작업을 진행하고, Redis 기반의 결과 캐싱 시스템을 도입했습니다.  
기능별로 3개의 마이크로서비스로 나누어 각 서비스의 특성에 맞는 k8s 설정(Pod별 리소스 할당, Probe 설정, 트래픽 기반 HPA 설정, Ingress 설정 등)을 통해 스케일링되도록 하였습니다.  
또한, CronJob을 통해 피크타임에 대비하여 미리 Node와 Pod를 늘리도록 하여 Cold Start와 Scaling Delay를 해결하였습니다.  
이러한 최적화를 통해 피크 시간대에도 평균 응답 시간을 20ms 이하로 유지할 수 있었습니다.

## DevOps 서비스 개발 프로젝트

### 활용 기술

- 인프라/클라우드: AWS, Container
- 백엔드: Spring Cloud(Java), JPA, MyBatis
- 프론트엔드: Vue, Vuex, JavaScript, HTML, CSS
- 데이터베이스: MariaDB, Redis, RabbitMQ
- CI/CD: Concourse CI, Maven, Nexus, AWS CodeStar, Harbor
- 모니터링/기타 도구: Rancher, Prometheus, Grafana, SonarQube, GitLab

### 본인의 역할

- 개발 파트 Lead
- 기술적 의사 결정(오픈소스 검토, 기술 스택 결정, 코딩 표준 및 스타일 가이드 설정, 코드베이스 구조 설계 등)
- 아키텍처 설계(Application Area), 데이터베이스 설계, 백엔드/프론트엔드 개발

### 진행 방식

- PoC, MVP, 제품화, 서비스 운영의 단계별 로드맵 수립 후 2주 단위 스프린트로 개발 진행
- 백엔드 개발자, 프론트엔드 개발자로 구성된 팀 운영

### 문제 해결 경험

- 개발자와 DevOps 엔지니어 간 이해도 차이 문제: Jenkins와 같은 CI 도구를 사용해본 경험은 있지만 DevOps 개념을 처음 접하는 개발자들과, 인프라 엔지니어에서 DevOps 엔지니어로 커리어를 발전시켜온 팀원들 사이에 기술적 이해도 차이로 인한 소통 문제가 발생했습니다.  
개발자들은 CI/CD 파이프라인 구성과 컨테이너화에 대한 이해가 부족했고, DevOps 엔지니어들은 백엔드(자바)와 프론트엔드(Vue) 등 각기 다른 언어와 프레임워크들의 워크플로우와 요구사항을 충분히 이해하지 못했습니다.  
이를 해결하기 위해 4주간의 토이 프로젝트를 제안하여 양측이 함께 간단한 애플리케이션을 개발하고 배포하는 과정을 경험하게 했습니다.  
또한 스프린트에 기술 공유 세션 도입을 제안하여 실행했고, 이를 통해 컨테이너, 오케스트레이션, CI/CD 파이프라인 등의 개념을 개발자들에게 교육하고, 개발자들은 애플리케이션 아키텍처와 개발 프로세스를 DevOps 엔지니어들에게 설명하는 시간을 가졌습니다.  
DevOps Korea, AWS, Google, Pivotal 등이 주최하는 다양한 행사에 적극 참여하여 기술 트렌드를 파악하고, 다른 IT 회사들의 사례를 통해 DevOps의 중요성을 느끼도록 하였습니다.  
이러한 노력으로 본격적인 개발에 들어갈 때쯤 팀 간 이해도 차이가 크게 줄어들었고, 개발자들이 직접 CI/CD 파이프라인 구성에 참여하고 컨테이너 이미지를 최적화할 수 있게 되었으며, 
개발한 서비스를 직접 사용하며 서비스 개선을 더 효과적으로 할 수 있게 되었습니다.

# 도전적인 목표를 설정하여 주도적으로 추진해 본 경험을 공유해 주세요.

제가 가장 큰 도전으로 삼았던 경험은 메가존클라우드에서 DevOps 서비스 개발 당시 출시된 지 얼마 되지 않은 Vue.js 2.x와 Vuex를 프론트엔드 기술로 도입한 것이었습니다.
당시 국내에서는 많이 사용하지 않는 생소한 기술이었습니다. 제가 검토한 대부분의 JavaScript 프레임워크들 중에서 Vue.js가 직관적인 문법과 가벼운 무게, 그리고 학습 곡선이 상대적으로 완만하다는 점에서 프로젝트에 적합하다고 판단했습니다. 그러나 Vue 2.x는 출시된 지 얼마 되지 않아 참고할 만한 국내 사례도 찾기 어려웠습니다.
이런 상황에서 저는 도전적인 목표를 설정했습니다. 영문 공식 문서를 직접 번역하며 학습하고, 이를 바탕으로 Vue.js와 Vuex를 활용한 웹 애플리케이션을 개발하는 것이었습니다. 당시 팀에서는 프론트엔드 개발자가 퍼블리셔에서 커리어 전환을 하고 계신 한분 밖에 없었고, 새로운 기술을 도입하는 것에 대한 부담이 있었지만, 저는 Vue.js가 가진 잠재력을 확신했습니다.
먼저 영문 공식 문서를 번역기를 통해 번역하며 학습했습니다. 특히 Vuex의 상태 관리 패턴은 복잡한 개념이었지만, 도식화하여 이해하고 직접 개발하면서 공부했습니다.
작업 과정에서 가장 어려웠던 점은 MSA 환경에서의 인증 처리와 JWT 토큰 관리였습니다. 특히 인증 후 발급받은 JWT를 안전하게 저장하고, 인증 전후 상태에 따라 UI를 동적으로 변경하는 로직을 구현하는 데 많은 시간이 필요했습니다. 당시에는 마이크로서비스 간 일관된 인증 상태를 유지하면서도 보안 취약점을 최소화하는 방법에 대한 레퍼런스가 부족했기 때문에, 다양한 토큰 관리 패턴을 직접 시도해보며 가장 적합한 방식을 찾아내야 했습니다.
또한 번역과정에서 오역이나 잘못된 이해로 인한 구현 오류가 발생하기도 했습니다. 이러한 문제는 공식 GitHub 저장소의 이슈와 예제 코드를 분석하며 해결했고, Stack Overflow와 같은 커뮤니티의 도움을 받기도 했습니다.
결과적으로 6개월간의 개발 끝에 Vue.js와 Vuex를 활용한 반응형 웹 애플리케이션을 성공적으로 개발할 수 있었습니다.